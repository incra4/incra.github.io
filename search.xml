<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>斜率优化 DP</title>
      <link href="/2025/02/19/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/"/>
      <url>/2025/02/19/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/</url>
      
        <content type="html"><![CDATA[<p><strong>由于作者去年 tg 都没一等，文中有错误请大家多多提出。</strong></p><p>斜率优化是用来求解一系列 dp 方程形如 $f_i&#x3D;\displaystyle\min_{j&#x3D;1}^{i}{f_j+a_i+b_j+x_i\times y_j}$（其中 $a_i$ 表示只和 $i$ 有关的项，$b_j$ 为只和 $j$ 有关的项，$x_i\times y_j$ 表示 $i$ 有关的项和 $j$ 有关的项相乘得到的项）。</p><p>显然转移方程中 $\min$ 换为 $\max$ 也同理。</p><p>考虑把转移方程化简，得到 $f_i&#x3D;\displaystyle\min_{j&#x3D;1}^{i}{f_j+b_j+x_i\times y_j}+a_i$，此时，我们把上式与一次函数的结局联系起来，令 $Y&#x3D;f_j+b_j,k&#x3D;-x_i,X&#x3D;y_j$，此时方程即可化为 $f_i&#x3D;\displaystyle\min_{j&#x3D;1}^{i}{Y-kX}+a_i$。</p><p>此时，根据一次函数定义，可以得到 $Y-kX$ 表示的是经过经过点 $(X,Y)$ 的斜率为 $k$ 的直线的截距。所以我们只需要将斜率为 $k$ 的直线从下往上（如果是 $\max$ 就从上往下）贴合决策点，第一次经过的决策点即为更新 $f_i$ 最优的点。</p><p>通过观察以下图，可以发现中间的点 $B$ 和 $E$ 一定不会被任一斜率的最优直线经过，只有在下凸壳上的点才有可能对答案有贡献（大家别被下凸壳给吓到了，这里其实只是一个名词，与实际代码没有关系）。</p><p><img src="https://cdn.acwing.com/media/article/image/2024/07/28/109870_2d8f830c4c-20240728.png" alt="20240728.png"> </p><p>如果 $k,x$ 均对于 $i$ 单调递增，那么那么可以用单调队列实现，如果仅 $x$ 递增，那么可以用二分实现，其他情况可以用平衡树&#x2F;CDQ分治等算法优化，这里不展开（主要是作者根本不会 23333）。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>还是上式转移方程对应的代码，这里给出 $k,x$ 均对于 $i$ 递增的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[N],q[N];</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">q[++tt] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 这里 Y (i),X (i),K (i) 就是上式中推出的式子中的 Y,X,k</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span> <span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Y</span> (j) - <span class="built_in">Y</span> (i)) / (<span class="built_in">X</span> (j) - <span class="built_in">X</span> (i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">slope</span> (q[hh],q[hh + <span class="number">1</span>]) &lt; <span class="built_in">K</span> (i)) hh++;</span><br><span class="line">    f[i] = f[q[hh]] + a[i] + b[q[hh]] + x[i] * y[q[hh]]; <span class="comment">//转移方程</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">slope</span> (q[tt - <span class="number">1</span>],q[tt]) &gt; <span class="built_in">slope</span> (q[tt],i)) tt--;</span><br><span class="line">    q[++tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2120"><a href="#P2120" class="headerlink" title="P2120"></a><a href="https://www.luogu.com.cn/problem/P2120">P2120</a></h3><p>这里不选取任务安排系列的题目原因是非斜率优化部分过于麻烦。</p><p>下文中 $d_i$ 即为原题面中的 $x_i$。</p><p>考虑列出暴力转移方程 $f_i&#x3D;\displaystyle\min_{j&#x3D;0}^{i-1}{f_j+c_i+\sum_{k&#x3D;j+1}^{i}p_k\times(d_i-d_k)}$。（这里 $k$ 的范围为 $i$ 其实会好写一些，后面有解释）</p><p>展开，得到 $*&#x3D;\displaystyle\min_{j&#x3D;0}^{i-1}{f_j+c_i+(\sum_{k&#x3D;j+1}^{i}p_k\times d_i)- (\sum_{k&#x3D;j+1}^{i}p_k\times d_k)}$。</p><p>继续化简得到 $*&#x3D;\displaystyle\min_{j&#x3D;0}^{i-1}{f_j+c_i+d_i\times(\sum_{k&#x3D;j+1}^{i}p_k)- (\sum_{k&#x3D;j+1}^{i}p_k\times d_k)}$。</p><p>令 $g_{1,i}&#x3D;\displaystyle\sum_{j&#x3D;1}^i p_j$，$g_{2,i}&#x3D;\displaystyle\sum_{j&#x3D;1}^i (p_j\times d_j)$。</p><p>那么得到 $*&#x3D;\displaystyle\min_{j&#x3D;0}^{i-1}{f_j+c_i+d_i\times(g_{1,i}-g_{1,j})- (g_{2,i}-g_{2,j})}$。</p><p>展开并添加括号得到 $*&#x3D;\displaystyle\min_{j&#x3D;0}^{i-1}{f_j+g_{2,j}-d_i\times g_{1,j}}+c_i+d_i\times g_{1,i}-g_{2,i}$。</p><p>令 $Y&#x3D;f_j+g_{2,j},k&#x3D;d_i,X&#x3D;g_{1,j}$，那么 $\min$ 里的项就是 $\displaystyle\min_{j&#x3D;0}^{i-1}{Y-kX}$，显然可以用前面的式子进行优化。</p><p>注意到 $k$ 关于 $i$ 递增而递增，所以我们可以用单调队列维护下凸壳。</p><p>下面给出核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Y</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> f[i] + g2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">X</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> g1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">K</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span> <span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">X</span> (i) == <span class="built_in">X</span> (j)) <span class="keyword">return</span> <span class="built_in">Y</span> (j) - <span class="built_in">Y</span> (i) &gt; <span class="number">0</span> ? <span class="number">9e18</span> : <span class="number">-9e18</span>;<span class="comment">// 特判斜率正负无穷大</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">Y</span> (j) - <span class="built_in">Y</span> (i)) / (<span class="built_in">X</span> (j) - <span class="built_in">X</span> (i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x[++n] = <span class="number">3e9</span>;<span class="comment">// 添加哨兵，这题数据比较恶心</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) g1[i] = g1[i - <span class="number">1</span>] + p[i],g2[i] = g2[i - <span class="number">1</span>] + p[i] * x[i]; </span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">q[++tt] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">slope</span> (q[hh],q[hh + <span class="number">1</span>]) &lt; <span class="built_in">K</span> (i)) hh++;</span><br><span class="line">f[i] = f[q[hh]] + x[i] * (g1[i] - g1[q[hh]]) - (g2[i] - g2[q[hh]]) + c[i];</span><br><span class="line"><span class="comment">//cout &lt;&lt; q[hh] &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">slope</span> (q[tt - <span class="number">1</span>],q[tt]) &gt; <span class="built_in">slope</span> (q[tt],i)) tt--;</span><br><span class="line">q[++tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单总结一下，我们对于上述类似的转移方程，我们设 $Y$ 等于仅和 $j$ 有关的项，$k$ 等于有关 $i$ 的项和有关 $j$ 的项相乘的项中的 $i$ 的项（就是 $x_i\times y_j$ 中的 $x_i$），$X$ 等于有关 $i$ 的项和有关 $j$ 的项相乘的项中的 $j$ 的项（就是 $x_i\times y_j$ 中的 $y_j$）。</p><p>这样就讲完了最最最模板的斜率优化了。</p><p>求个赞不过分吧 QaQ</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
